324CA Ciorceanu Andrei Razvan

Problema 1:
	La aceasta problema, am facut un MergeSort pentru vectorul P[i] in care am stocat numarul de monede produse pe ora pentru fiecare calculator,pentru a updata mereu calculatorul care produce cele mai putine monede. Am ales MergeSort pentru ca este o sortare cu complexitate de O(n log n) si in sortare cand interschimbam elementele am interschimbat si elementele din U[i] ,unde am stocat costul de update al fiecarui calculator, pentru a ramane corespondenta de indici intre cei doi vectori.
	Am deschis fisierele de citire/afisare, am alocat memorie pentru vectorii pe care ii utilizez dupa care am sortat vectorii si am luat o variabila sum initializata cu 0 pentru a calcula costul dupa fiecare pas. Am luat primul element din P[i] ca fiind minim dupa care am facut un while in care adun la sum costul fiecarui calculator cat timp aceastea sunt egale cu minimul ales, daca sum depaseste B dam break,daca nu updatez fiecare calculator si iterez prin vectorul P. Atunci cand gasim un element care nu este egal cu minimul il updatam pe acesta si incepem din nou iteratie pentru a updata calculatoarele. ( In cazul in care avem de exemplu 2 2 2 2 4 4 4 6 dorim sa updatam toata calculatoarele cu P-ul egal cu 2 pana vor ajunge 4 daca Bugetul B ne permite acest lucru). La sfarsit am mai facut o sortare pentru a afisa minimul din vect P adica P[0],acesta fiind numarul maxim de monede produse intr o ora. Am inchis fisierele si am eliberat memoria.

Problema 2:
	Aceasta problema se aseamana cu problema rucsacului,care este rezoolvata in primul laborator de programare dinamica de pe OCW,numai ca in loc de capacitatea rucsacului vom acea buget maxim al lui Gigel,avand inca un parametru de verificat, ca pierderile sa nu depaseasca L. De aceea alocam un pointer ***dp 3D pentru a pastra toti acesti parametri pentru fiecare pas. Am definit un define care ne da maximul dintre 2 numere si o structura de actiune pentru care am definit si vectorul de actiuni A. Deoarece avem 3 for uri pentru a parcuruge toate obiectele si a verifica Bugetul si Pierderile maxime compelxitatea algoritmului este de O(N * B * L) si procedam ca in cazul prooblemei rucsac. Daca nu folosim obiectul curent solutia este aceeasi ca la pasul i-1,daca il folosim si trece de verificarile necesare de buget/pierderi adaugam profitul la solutia anterioara si vom lua in continuare maximul dintre soluatia actuala si cea actuala la care a fost adaugat profitul. La final vom elibera memoria pentru vectorul 3D si inchidem fisierele.

Problema 3:
	La aceasta problema alocam un vector de dimensiune N cu inaltimile muntilor. Cautam minimul din vector,punctul in care se formeaza valea, daca exista mai multe minime aceastea trebuie sa fie consecutive si retinem pozitia primului si a ultimului. Parcurgem elementele de la primul munte pana la minim si vedem daca respecta conditia de vale,daca sunt descrescatoare, daca nu scadem elementele si updatam hours. Parcurgem elementele de la minim pana la sfarsit si verificam din nou conditia de vale, in acest caz elementele trebuie sa fie crescatoare, daca nu sunt decrementam inaltimile si updatam hours. La sfarsit afisam numarul de ore si inchidem fisierele. Complexitatea algoritmului este de O(N).

Problema 4:
	La aceasta problema mi am definit 2 functii de comparare una pentru 2 numere,una pentru 3 numere, am initializat vectorii de lungime N cu intaltimile fiecarui munte si costul pentru a fi micsorat cu o unitate. Am alocat matricea pentru a face programare dinamica fiind o problema de cost minim, cu 3 coloane pentru fiecare diferenta dintre 2 munti consecutivi,daca aceasta este 0,1 sau 2. Am stabilit cazurile de baza si am luat fiecare caz in parte in care inaltimea dintre 2 munti consecutivi poate fi -2,-1,0,1,2 sau mai mare de 2 respectiv -2. Pentru fiecare caz am stabilit minimele in functie de cat se poate scadea din muntele curent astfel incat acesta sa fie diferit de cel de dinainte si am adunat costul la acel minim din matricea dp. Am verificat la fiecare caz daca inaltimea este mai mare de 2(a muntelui curent) pentru ca in cazul unei diferente de 2 acesta sa nu ajunga la o inaltime negativa. Complexitatea algoritmului este O(N).

Problema 5:
	La aceasta problema am folosit functiile de inmultire si ridicare la putere a unei matrici din laboratorul de programare dinamica de pe OCW, unde dimensiunea matricei este KMAX=4 de 4x4, acest lucru ducand la o complexitate a algoritmului de O(KMAX ^ 3 * logN) = O(logN).Am identificat recurenta pentru fiecare N si astfel am obtinut formula dp[i] = dp[i-1] + dp[i-3] + 3. Am stabilit cazurile de baza pentru N = 0,1,2. Matricea am identificat folosind o recurenta din lab si anume S5 = C * S4 unde S5 = [16 10 6 3] si S4 = [10 6 3 3],ultimul element din acest vector fiind constanta 3 din recurenta. Ridicam matricea la puterea N-3 deoarece stare S4 depinde doar de 3 stari anterioare(S3,S2,S1) ultimul element fiind constanta 3. Astfel avem formula din laborator Sn = S3 * C ^(N-3) iar numarul nostru cautat va fi format din inmultirea vectorului cu prima linie din matricea noastra. Am facut acest numar modulo MOD si l am afisat. Aceste numere au fost obtinute prin incercarea de a scris dp[i] sub forma unei sume din cazurile de baza si niste coeficienti astfel am obtinut dp[i] = a * dp[i-1] + b * dp[i-2] + c * dp[i-3] +const
unde const =3, a = 6 ,b =3 ,c =1 deoarece stare S3 = [dp[3], dp[2], dp[1], 3] = [6 3 1 3]
